**Данный проект - решение тестового задания Для Безымянной компании**
**Наменование компании обезличено во избежание копирования решения**
**Исходный `.csv` файл заменен на бесплатный sample длиной 100 тысяч строк**
**Автор решения - Тамерлан Халилов**

---

## Суть приложения

**Приложение парсит `.csv` файл и отображает его в виде постраничной таблицы**
**Пользователь может задать число столбцов, отображаемых на одной странице, переключаться между страницами, в том числе вводя в поиске конкретную страницу**

---

## Шаги для запуска

! (`docker` должен быть запущен) !

1. Скачайте репозиторий проекта (корневую папку)
2. Внутри терминала (в IDE или в системе) после перхода к скачанной папке (`cd` к папке) запустите команды:

- `docker build -t app .` // создаем docker image
- `docker run -p 8085:8085 app` // создаем и запускаем контейнер из docker image
  app - это название приложения для докера, можно использовать любое другое
  Сервер должен запуститься, он будет доступен по url: `http://127.0.0.1:8085/` и по `http://localhost:8085/`.

## Описание решения

Стек технологий, который использовался в решении:

- Фреймворк `React`
- Сборщик модулей `vite`
- Парсер .csv файлов `papaparse`
- `docker`

Как работает приложение-решение:

- Функция `getCsv` парсит исходный `.csv` файл (находится в папке public), игнорируя первую строку (с названиями столбцов)
- Во время парсинга эта функция записывает первые пять столбцов исходного файла в двумерный массив `data` (перменная состояния, созданная с помощью хука `useState`)
- Внутри этого массива находятся массивы длиной 5 элементов, длина самого массива соответствует количеству строк в исходном файле без строки с названиями столбцов
- Пока .csv файл парсится, вместо всего этого отрисовывается один заголовок с надписью "Подождите, читаем файл.."
- В приложении присутствуют органы управления, а именно:

1. Карточка, в которой есть:

- поле ввода желаемого количества отображаемых рядов (строк) в таблице значений. Оно принимает текст, если этот текст является числом в диапазоне между 10 и 500, компонент отрисовывает страницы таблицы, c указанным числом рядов (строк)
- кнопка возврата к исходному значению. Она просто возвращает исходное количество рядов (30) и переносит пользователя на первую страницу таблицы

2. Поле ввода номера желаемой страницы (страница отрисовывается исходя из имеющегося диапазона на основе указанного пользователем числа)
3. Стрелки (кнопки) для переключения страниц вручную
4. Текущая страница / из всего страниц

# Сама страница таблицы отрисовывается по следующему принципу:

1. При рендере таблицы всегда рендерится первая строка таблицы (ее заглавие), таблица состоит из 6 столбцов: номер строки и 5 названий столбцов, взятых из исходного файла .csv
2. Далее для рендера оставшейся части таблицы компонент вызывает функцию `createSmallArray`, которая создает небольшой массив, размер которого <= текущему количеству рядов (строк) в таблице.

Для этого функция вычисляет "левый" и "правый" индексы текущей страницы, затем достает из массива `data` небольшой подмамссив элементов по этим индексам и возвращает его в компонент. Вычисления происходят исходя из номера текущей страницы, числа рядов таблицы на странице и общей длины массива `data`.

Поскольку эта функция получает подмассив элементов массива `data` по индексам, а в среднем операция получения элемента массива по индексу имеет сложность O(1), а получение нескольких элементов массива - O(n), где n - это разница между "правым" и "левым" индексами, получение "маленького массива" происходит довольно быстро, соответственно, отрисовка просходит практически мгновенно.

# Плюсы решения

- контроль пользователя над тем, сколько строк он хочет видеть в таблице на одной странице
- довольно высокая скорость работы после завершения парсинга исходного .csv файла

# Что можно было бы улучшить

- вынести отрисовку таблицы в отдельный компонент (например, с названием Table)
- отслеживать переменные состояния (их пять) и менять их значения с помощью стейт-менеджера вроде MobX/Redux
- вынести функции парсинга и функцию для создания "маленького массива" в отдельный файл, чтобы облегчить внешний вид React-компонента
- сделать указанные функции и сам возвращаемый jsx более простыми (K.I.S.S) и читаемыми
- добавить адаптивную верстку
